import type { ASTModification, ASTOperation } from './omega-model';

export interface ResolvedEdit {
  oldString: string;
  newString: string;
}

export interface ValidationResult {
  valid: boolean;
  errors: string[];
}

export interface ConflictReport {
  conflict: boolean;
  files: string[];
}

function getLines(content: string): string[] {
  return content.split('\n');
}

function joinLines(lines: string[]): string {
  return lines.join('\n');
}

function applyOperation(op: ASTOperation, workingContent: string): ResolvedEdit[] {
  const edits: ResolvedEdit[] = [];
  const lines = getLines(workingContent);

  switch (op.type) {
    case 'raw_edit':
      edits.push({ oldString: op.oldString, newString: op.newString });
      break;
    case 'replace_block': {
      const oldLines = lines.slice(op.startLine - 1, op.endLine);
      edits.push({
        oldString: joinLines(oldLines),
        newString: op.newCode,
      });
      break;
    }
    case 'delete_lines': {
      const oldLines = lines.slice(op.startLine - 1, op.endLine);
      edits.push({
        oldString: joinLines(oldLines),
        newString: '',
      });
      break;
    }
    case 'insert_import': {
      const importBlock = lines.filter((l) => l.trim().startsWith('import ')).join('\n');
      const statement = `import { ${op.specifiers.join(', ')} } from '${op.module}';`;
      edits.push({
        oldString: importBlock,
        newString: importBlock ? `${importBlock}\n${statement}` : statement,
      });
      break;
    }
    case 'create_file':
      edits.push({ oldString: '', newString: op.content });
      break;
    default:
      // For non-trivial AST ops, fall back to raw replacement pattern generated by caller.
      break;
  }
  return edits;
}

export function resolveASTOperations(
  operations: ASTOperation[],
  fileContent: string,
): ResolvedEdit[] {
  let working = fileContent;
  const resolved: ResolvedEdit[] = [];
  for (const op of operations) {
    const edits = applyOperation(op, working);
    for (const edit of edits) {
      resolved.push(edit);
      if (edit.oldString && working.includes(edit.oldString)) {
        working = working.replace(edit.oldString, edit.newString);
      } else if (!edit.oldString) {
        working = edit.newString;
      }
    }
  }
  return resolved;
}

export function validateOperations(operations: ASTOperation[], fileContent: string): ValidationResult {
  const errors: string[] = [];
  for (const op of operations) {
    if (op.type === 'replace_block' || op.type === 'delete_lines') {
      const lines = getLines(fileContent);
      if (op.startLine < 1 || op.endLine > lines.length || op.startLine > op.endLine) {
        errors.push(`Invalid line range for ${op.type}: ${op.startLine}-${op.endLine}`);
      }
    }
    if (op.type === 'raw_edit' && !fileContent.includes(op.oldString)) {
      errors.push('raw_edit oldString was not found in file content');
    }
  }
  return { valid: errors.length === 0, errors };
}

export function detectConflicts(modsA: ASTModification[], modsB: ASTModification[]): ConflictReport {
  const filesA = new Set(modsA.map((m) => m.filePath));
  const filesB = new Set(modsB.map((m) => m.filePath));
  const overlap: string[] = [];
  for (const file of filesA) {
    if (filesB.has(file)) overlap.push(file);
  }
  return { conflict: overlap.length > 0, files: overlap };
}
